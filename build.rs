use std::env;
use std::path::Path;
use std::process::{Command, Stdio}; // Import Command and Stdio

fn main() {
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let install_dir = Path::new(&out_dir); // Use Path for easier joining

    // --- Build Qhull ---
    println!("Building Qhull...");
    build_qhull(install_dir);

    // --- Build CFITSIO ---
    println!("Building CFITSIO...");
    build_cfitsio(install_dir);

    // --- Build GSL ---
    println!("Building GSL...");
    build_gsl(install_dir);

    // --- Link Libraries ---
    // Tell Cargo where to find the compiled libraries
    // Libraries are usually installed in <install_dir>/lib
    // println!(
    //     "cargo:rustc-link-search=native={}",
    //     install_dir.join("lib").display()
    // );

    // // Tell Cargo to link against the compiled static libraries
    // // Confirm the exact library names generated by the make install step!
    // println!("cargo:rustc-link-lib=static=qhullstatic"); // Example name for Qhull
    // println!("cargo:rustc-link-lib=static=cfitsio"); // Example name for CFITSIO
    // println!("cargo:rustc-link-lib=static=gsl"); // Example name for GSL
    // println!("cargo:rustc-link-lib=static=gslcblas"); // Example name for GSL Cblas

    // // Link system libraries that the C code depends on (GSL often needs libm)
    // if cfg!(target_os = "linux") || cfg!(target_os = "macos") {
    //     println!("cargo:rustc-link-lib=m");
    // }

    // CFITSIO might require linking against system zlib or bz2 if compiled with
    // compression support enabled via configure options. Add these if necessary.
    // println!("cargo:rustc-link-lib=z");
    // println!("cargo:rustc-link-lib=bz2");

    // If using bindgen, tell it where to find the headers
    // println!("cargo:include={}", install_dir.join("include").display());
}

// Function to execute a command and panic on failure
fn run_command(command: &mut Command, command_name: &str, cwd: &Path) {
    println!("Executing command: {:?} in {:?}", command, cwd);
    let status = command
        .current_dir(cwd)
        .stdout(Stdio::inherit()) // Pipe stdout of command to Cargo build output
        .stderr(Stdio::inherit()) // Pipe stderr of command to Cargo build output
        .status()
        .unwrap_or_else(|e| panic!("Failed to execute {}: {}", command_name, e));

    if !status.success() {
        panic!("Command failed with status: {}", status);
    }
}

// Function to build Qhull using Command
fn build_qhull(install_dir: &Path) {
    let qhull_src_dir = Path::new("vendor/qhull"); // Path to your qhull submodule

    // --- Step 1: Configure (if needed) ---
    // Check Qhull docs/Makefile if a configure step is necessary.
    // If not, skip directly to make.
    // Example if there's a simple configure script:
    // run_command(Command::new("./configure").arg(format!("--prefix={}", install_dir.display())), "Qhull configure", &qhull_src_dir);

    // --- Step 2: Make ---
    // Build the library. Check Qhull Makefile for specific targets if needed.
    let mut make_command = Command::new("make");
    make_command.current_dir(qhull_src_dir); // Run make from the qhull submodule directory
    run_command(&mut make_command, "Qhull make", qhull_src_dir);

    // --- Step 3: Install ---
    // Install built files to the specified prefix (OUT_DIR)
    // Check Qhull Makefile if it supports 'make install' and how it uses PREFIX or DESTDIR.
    // Often, `make install PREFIX=/path/to/install` is the pattern after a configure step set up the Makefile.
    // If no configure, the Makefile might expect PREFIX directly.
    run_command(
        Command::new("make")
            .arg("install")
            .arg(format!("PREFIX={}", install_dir.display())),
        "Qhull make install",
        qhull_src_dir,
    );

    println!("Finished building Qhull.");
    // After installation, headers should be in install_dir/include, libs in install_dir/lib
}

// Function to build CFITSIO using Command (Autotools pattern)
fn build_cfitsio(install_dir: &Path) {
    let cfitsio_src_dir = Path::new("vendor/cfitsio"); // Path to your cfitsio submodule

    // --- Step 1: Configure ---
    // Run the configure script from the source directory
    let mut configure_command = Command::new("./configure");
    configure_command.arg(format!("--prefix={}", install_dir.display())); // Install into OUT_DIR
    configure_command.arg("--enable-static"); // Build static library
    configure_command.arg("--disable-shared"); // Explicitly disable shared library
    configure_command.arg(format!(
        "--host={}",
        env::var("TARGET").expect("TARGET not set")
    )); // Set host target
        // Add any other necessary configure options here (e.g., compression flags)
        // configure_command.arg("--with-zlib");

    run_command(&mut configure_command, "CFITSIO configure", cfitsio_src_dir);

    // --- Step 2: Make ---
    // Build the library
    let mut make_command = Command::new("make");
    make_command.current_dir(cfitsio_src_dir); // Run make from the cfitsio submodule directory
    run_command(&mut make_command, "CFITSIO make", cfitsio_src_dir);

    // --- Step 3: Install ---
    // Install built files. 'make install' should respect the --prefix set during configure.
    run_command(
        Command::new("make").arg("install"),
        "CFITSIO make install",
        cfitsio_src_dir,
    );

    println!("Finished building CFITSIO.");
    // After installation, headers should be in install_dir/include, libs in install_dir/lib
}

// Function to build GSL using Command (Autotools pattern)
fn build_gsl(install_dir: &Path) {
    let gsl_src_dir = Path::new("vendor/gsl"); // Path to your gsl submodule

    // --- Step 0: Run autogen.sh ---
    // This generates the configure script and Makefiles from the source files.
    // Only needed when building from a Git clone/submodule, not official tarballs.
    let mut autogen_command = Command::new("./autogen.sh");
    run_command(&mut autogen_command, "GSL autogen.sh", gsl_src_dir);

    // --- Step 1: Configure ---
    let mut configure_command = Command::new("./configure");
    configure_command.arg(format!("--prefix={}", install_dir.display())); // Install into OUT_DIR
    configure_command.arg("--enable-static"); // Build static library
    configure_command.arg("--disable-shared"); // Explicitly disable shared library
    configure_command.arg(format!(
        "--host={}",
        env::var("TARGET").expect("TARGET not set")
    )); // Set host target
        // Add any other necessary configure options here
        // configure_command.arg("--disable-dependency-tracking");

    run_command(&mut configure_command, "GSL configure", gsl_src_dir);

    // --- Step 2: Make ---
    let mut make_command = Command::new("make");
    make_command.current_dir(gsl_src_dir); // Run make from the gsl submodule directory
    run_command(&mut make_command, "GSL make", gsl_src_dir);

    // --- Step 3: Install ---
    // 'make install' should respect the --prefix set during configure.
    run_command(
        Command::new("make").arg("install"),
        "GSL make install",
        gsl_src_dir,
    );

    println!("Finished building GSL.");
    // After installation, headers should be in install_dir/include, libs in install_dir/lib
}
